/<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>An Introduction of Intersectional Tech: Black Users in Digital Gaming</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/loaders/GLTFLoader.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.6;
            color: #333;
            background: #fff;
        }
        article { max-width: 900px; margin: 0 auto; padding: 48px 24px; }
        header { margin-bottom: 48px; }
        h1 { font-size: 2.5rem; font-weight: bold; color: #111; margin-bottom: 16px; }
        .meta { color: #666; font-size: 0.875rem; }
        h2 { font-size: 1.75rem; font-weight: bold; color: #111; margin-top: 40px; margin-bottom: 16px; }
        p { color: #444; margin-bottom: 24px; font-size: 1.125rem; }
        p.lead { font-size: 1.25rem; color: #555; }
        .model-container { margin: 48px 0; }
        .model-viewer {
            width: 100%; height: 600px; background: #f5f5f5;
            border-radius: 8px; position: relative; overflow: hidden;
            touch-action: none; cursor: grab;
        }
        .model-viewer:active { cursor: grabbing; }
        .model-viewer canvas { display: block; width: 100%; height: 100%; }
        .loading {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%); color: #666; font-size: 1rem;
        }
        .caption {
            margin-top: 8px; font-size: 0.875rem; color: #666;
            font-style: italic; text-align: center;
        }
        .instructions { 
            margin-top: 4px; font-size: 0.75rem; color: #999; 
            text-align: center; 
        }
        .scroll-hint {
            position: absolute; bottom: 80px; left: 50%;
            transform: translateX(-50%);
            color: #666; font-size: 0.875rem;
            padding: 8px 16px; background: rgba(255,255,255,0.9);
            border-radius: 20px; pointer-events: none;
            opacity: 0.8; animation: fadeInOut 3s ease-in-out infinite;
        }
        @keyframes fadeInOut {
            0%, 100% { opacity: 0.4; }
            50% { opacity: 0.8; }
        }
        .zoom-controls {
            position: absolute; bottom: 20px; right: 20px;
            display: flex; flex-direction: column; gap: 10px; z-index: 10;
        }
        .zoom-btn {
            width: 44px; height: 44px; background: white;
            border: 2px solid #ddd; border-radius: 8px; cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            font-size: 1.25rem; color: #333; transition: all 0.2s;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .zoom-btn:hover { background: #f8f8f8; border-color: #999; transform: scale(1.05); }
        .zoom-btn:active { transform: scale(0.95); }
        .movement-controls {
            position: absolute; bottom: 20px; right: 80px;
            display: grid; grid-template-columns: repeat(3, 44px);
            grid-template-rows: repeat(3, 44px); gap: 4px; z-index: 10;
        }
        .move-btn {
            width: 44px; height: 44px; background: white;
            border: 2px solid #ddd; border-radius: 8px; cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            font-size: 1.25rem; color: #333; transition: all 0.2s;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .move-btn:hover { background: #f8f8f8; border-color: #999; transform: scale(1.05); }
        .move-btn:active { transform: scale(0.95); }
        .move-up { grid-column: 2; grid-row: 1; }
        .move-left { grid-column: 1; grid-row: 2; }
        .move-right { grid-column: 3; grid-row: 2; }
        .move-down { grid-column: 2; grid-row: 3; }
        .ar-button {
            position: absolute; bottom: 20px; left: 20px;
            background: white; border: 2px solid #ddd;
            border-radius: 8px; padding: 12px 20px;
            font-size: 0.9rem; font-weight: 600;
            color: #333; cursor: pointer;
            display: none; align-items: center; gap: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            transition: all 0.2s; z-index: 10;
            text-decoration: none;
        }
        .ar-button.visible { display: flex; }
        .ar-button:hover { background: #f8f8f8; border-color: #999; transform: scale(1.05); }
        .ar-button:active { transform: scale(0.95); }
        .ar-icon {
            width: 20px; height: 20px;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="2" y="2" width="20" height="20" rx="2"/><path d="M12 2v20M2 12h20"/></svg>') center no-repeat;
            background-size: contain;
        }
    </style>
</head>
<body>
    <article>
        <header>
            <h1>An Introduction of Intersectional Tech: Black Users in Digital Gaming</h1>
            <div class="meta">
                <span>By Qitian Jiang</span>
                <span> ‚Ä¢ </span>
                <span>November 1, 2025</span>
            </div>
        </header>

        <p class="lead">
            I came to know this book through Dr. Corbitt's recommendation and found it to be a wonderful companion during my travels. 
            Its insights into intersectional technology and Black users' experiences in digital gaming have enriched my understanding of inclusive design.
        </p>

        <h2>The Scholar Behind the Work</h2>

        <p>
            Dr. Kishonna Gray serves as a Professor of Racial Justice and Technology at the University of Michigan's School of Information and Director of the Intersectional Tech Lab. Her groundbreaking research examines how technology has impacted culture and how marginalized users influence the creation of technological spaces and artifacts.
        </p>

        <p>
            Based on analyses of game play, platform design, and digital infrastructures, she interrogates the profound ways in which technology shapes identity and community. Gray's work challenges us to reconsider who designs our digital worlds and whose experiences are centered in those designs.
        </p>

        <div class="model-container">
            <div class="model-viewer" id="model1">
                <div class="loading">Loading 3D model...</div>
                <div class="scroll-hint">Drag to rotate ‚Ä¢ WASD to move</div>
                <a href="#" rel="ar" class="ar-button" id="ar-button">
                    <div class="ar-icon"></div>
                    <span>View in AR</span>
                </a>
                <div class="movement-controls">
                    <button class="move-btn move-up" id="move-forward" title="Move Forward (W)">‚Üë</button>
                    <button class="move-btn move-left" id="move-left" title="Move Left (A)">‚Üê</button>
                    <button class="move-btn move-right" id="move-right" title="Move Right (D)">‚Üí</button>
                    <button class="move-btn move-down" id="move-backward" title="Move Backward (S)">‚Üì</button>
                </div>
                <div class="zoom-controls">
                    <button class="zoom-btn" id="zoom-in" title="Zoom In">üîç+</button>
                    <button class="zoom-btn" id="zoom-out" title="Zoom Out">üîç‚àí</button>
                </div>
            </div>
            <p class="caption">Fig. 1: The 3D scanned object of the book.</p>
            <p class="instructions">Drag to rotate ‚Ä¢ Scroll or use buttons to zoom ‚Ä¢ Use WASD or arrow buttons to move ‚Ä¢ Tap "View in AR" on iPhone to see in your space</p>
        </div>

        <p>
            This book examines how Black gamers navigate digital spaces marked by what Dr. Gray calls "digital Jim Crow"‚Äîthe normalization of whiteness and masculinity that leads to isolation and exclusion of marginalized users. Through extensive interviews, she reveals how multiple identities intersect in gaming culture, centering voices typically silenced by hegemonic narratives. The book argues that despite pervasive discrimination, gaming spaces hold potential for fostering critical consciousness and effecting social change.
        </p>

        <p>
            Gray‚Äôs commitment to centering marginalized voices through careful ethnographic observation transforms moments, like the one on page 68, into ethical encounters that demand attention. As a former journalist and now gradually an apprentice researcher, I was deeply moved by this particular observation note. In it, Dr. Gray describes an interviewee who was disheartened by the injustice surrounding their racial identification. She was deeply concerned, but could not offer counseling immediately, for her role was researcher rather than friend. She desperately hoped there could be other players jumping in to make that interviewee feel better, and thankfully there were other players who took over the topic and relieved that interviewee's distress.
        </p>

        <p>
            My eyes were a bit wet, for when I worked as a journalist, authenticity was always something put ahead of sympathy. Sometimes difficult things just happen and what I could do was watch, ask, and report. There was nothing I could really do to relieve or assist, just as in the same dilemma as a researcher - being professional sometimes means prioritizing excellence over some human feelings. Perhaps the lesson here is not to resolve this tension between professionalism and empathy, but to carry it consciously into my research, letting it inform how I listen and what I choose to amplify in the multicultural voices I encounter.
        </p>
    </article>

    <script>
        function init3DViewer(containerId, arButtonId, zoomInId, zoomOutId, moveForwardId, moveBackwardId, moveLeftId, moveRightId, modelUrl, usdzUrl, testingMode) {
            const container = document.getElementById(containerId);
            const loading = container.querySelector('.loading');
            const arButton = document.getElementById(arButtonId);
            const scrollHint = container.querySelector('.scroll-hint');
            
            // Check for AR support (iOS Quick Look)
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
            
            // Show AR button if iOS and USDZ provided, or if in testing mode
            if ((isIOS || testingMode) && usdzUrl && arButton) {
                arButton.href = usdzUrl;
                arButton.classList.add('visible');
            }
            
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf5f5f5);
            const camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(0, 2, 8);
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);
            
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const dirLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight1.position.set(5, 10, 5);
            scene.add(dirLight1);
            const dirLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
            dirLight2.position.set(-5, 5, -5);
            scene.add(dirLight2);
            
            let model = null;
            let targetZ = 8;
            const minZ = 2;
            const maxZ = 15;
            
            // ========== CONFIGURATION: Change these values ==========
            // Initial rotation of the model in DEGREES (0-360)
            const initialRotationDegrees = {
                x: 0,    // X-axis tilt in degrees
                y: 45,   // Y-axis spin in degrees
                z: 0     // Z-axis roll in degrees
            };
            // =======================================================
            
            // Convert degrees to radians for Three.js
            const initialRotation = {
                x: initialRotationDegrees.x * (Math.PI / 180),
                y: initialRotationDegrees.y * (Math.PI / 180),
                z: initialRotationDegrees.z * (Math.PI / 180)
            };
            
            // Rotation controlled by dragging
            let targetRotation = { x: 0, y: 0, z: 0 };
            
            // Drag interaction variables
            let isDragging = false;
            let previousMouse = { x: 0, y: 0 };
            
            // Keyboard controls
            let keys = {};
            let buttonMovement = { forward: false, backward: false, left: false, right: false };
            const moveSpeed = 0.1;
            
            document.addEventListener('keydown', (e) => {
                keys[e.key.toLowerCase()] = true;
            });
            
            document.addEventListener('keyup', (e) => {
                keys[e.key.toLowerCase()] = false;
            });
            
            // Scroll control
            let scrollPosition = 0;
            const scrollSensitivity = 0.02;
            
            function handleScroll(e) {
                if (!model) return;
                
                const delta = e.deltaY;
                
                // Update camera position (negative delta so scroll down = move closer)
                targetZ -= delta * scrollSensitivity;
                targetZ = Math.max(minZ, Math.min(maxZ, targetZ));
                
                // Hide scroll hint after first interaction
                if (scrollHint) {
                    scrollHint.style.display = 'none';
                }
            }
            
            // Mouse wheel for desktop - listen on window for global scroll
            window.addEventListener('wheel', handleScroll, { passive: true });
            
            // Touch events for mobile
            let touchStartY = 0;
            window.addEventListener('touchstart', (e) => {
                touchStartY = e.touches[0].clientY;
            }, { passive: true });
            
            window.addEventListener('touchmove', (e) => {
                if (!model) return;
                
                const touchY = e.touches[0].clientY;
                const delta = touchStartY - touchY;
                
                // Update camera position (positive delta so swipe up = move closer)
                targetZ += delta * 0.01;
                targetZ = Math.max(minZ, Math.min(maxZ, targetZ));
                
                touchStartY = touchY;
                
                // Hide scroll hint after first interaction
                if (scrollHint) {
                    scrollHint.style.display = 'none';
                }
            }, { passive: true });
            
            // Mouse drag controls for rotation
            renderer.domElement.addEventListener('mousedown', (e) => {
                isDragging = true;
                previousMouse = { x: e.clientX, y: e.clientY };
            });
            
            renderer.domElement.addEventListener('mousemove', (e) => {
                if (isDragging && model) {
                    const deltaX = e.clientX - previousMouse.x;
                    const deltaY = e.clientY - previousMouse.y;
                    targetRotation.y += deltaX * 0.01;
                    targetRotation.x += deltaY * 0.01;
                    previousMouse = { x: e.clientX, y: e.clientY };
                    
                    // Hide scroll hint after first interaction
                    if (scrollHint) {
                        scrollHint.style.display = 'none';
                    }
                }
            });
            
            document.addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            renderer.domElement.addEventListener('mouseleave', () => {
                isDragging = false;
            });
            
            // Touch drag controls for rotation
            let touchDragStart = { x: 0, y: 0 };
            let isTouchDragging = false;
            
            renderer.domElement.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    isTouchDragging = true;
                    const touch = e.touches[0];
                    touchDragStart = { x: touch.clientX, y: touch.clientY };
                }
            }, { passive: true });
            
            renderer.domElement.addEventListener('touchmove', (e) => {
                if (isTouchDragging && model && e.touches.length === 1) {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const deltaX = touch.clientX - touchDragStart.x;
                    const deltaY = touch.clientY - touchDragStart.y;
                    targetRotation.y += deltaX * 0.01;
                    targetRotation.x += deltaY * 0.01;
                    touchDragStart = { x: touch.clientX, y: touch.clientY };
                    
                    // Hide scroll hint after first interaction
                    if (scrollHint) {
                        scrollHint.style.display = 'none';
                    }
                }
            }, { passive: false });
            
            renderer.domElement.addEventListener('touchend', () => {
                isTouchDragging = false;
            });
            
            // Zoom button controls
            const zoomSpeed = 0.5;
            const zoomInBtn = document.getElementById(zoomInId);
            const zoomOutBtn = document.getElementById(zoomOutId);
            
            if (zoomInBtn) {
                zoomInBtn.addEventListener('click', () => {
                    targetZ -= zoomSpeed;
                    targetZ = Math.max(minZ, Math.min(maxZ, targetZ));
                });
            }
            
            if (zoomOutBtn) {
                zoomOutBtn.addEventListener('click', () => {
                    targetZ += zoomSpeed;
                    targetZ = Math.max(minZ, Math.min(maxZ, targetZ));
                });
            }
            
            // Movement button controls - hold to move continuously
            const moveForwardBtn = document.getElementById(moveForwardId);
            const moveBackwardBtn = document.getElementById(moveBackwardId);
            const moveLeftBtn = document.getElementById(moveLeftId);
            const moveRightBtn = document.getElementById(moveRightId);
            
            if (moveForwardBtn) {
                moveForwardBtn.addEventListener('mousedown', () => {
                    buttonMovement.forward = true;
                });
                moveForwardBtn.addEventListener('mouseup', () => {
                    buttonMovement.forward = false;
                });
                moveForwardBtn.addEventListener('mouseleave', () => {
                    buttonMovement.forward = false;
                });
                // Touch support
                moveForwardBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    buttonMovement.forward = true;
                });
                moveForwardBtn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    buttonMovement.forward = false;
                });
            }
            
            if (moveBackwardBtn) {
                moveBackwardBtn.addEventListener('mousedown', () => {
                    buttonMovement.backward = true;
                });
                moveBackwardBtn.addEventListener('mouseup', () => {
                    buttonMovement.backward = false;
                });
                moveBackwardBtn.addEventListener('mouseleave', () => {
                    buttonMovement.backward = false;
                });
                // Touch support
                moveBackwardBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    buttonMovement.backward = true;
                });
                moveBackwardBtn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    buttonMovement.backward = false;
                });
            }
            
            if (moveLeftBtn) {
                moveLeftBtn.addEventListener('mousedown', () => {
                    buttonMovement.left = true;
                });
                moveLeftBtn.addEventListener('mouseup', () => {
                    buttonMovement.left = false;
                });
                moveLeftBtn.addEventListener('mouseleave', () => {
                    buttonMovement.left = false;
                });
                // Touch support
                moveLeftBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    buttonMovement.left = true;
                });
                moveLeftBtn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    buttonMovement.left = false;
                });
            }
            
            if (moveRightBtn) {
                moveRightBtn.addEventListener('mousedown', () => {
                    buttonMovement.right = true;
                });
                moveRightBtn.addEventListener('mouseup', () => {
                    buttonMovement.right = false;
                });
                moveRightBtn.addEventListener('mouseleave', () => {
                    buttonMovement.right = false;
                });
                // Touch support
                moveRightBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    buttonMovement.right = true;
                });
                moveRightBtn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    buttonMovement.right = false;
                });
            }
            
            window.addEventListener('resize', () => {
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            });
            
            const loader = new THREE.GLTFLoader();
            loader.load(modelUrl, (gltf) => {
                // Create a container group for proper centering
                const modelGroup = new THREE.Group();
                const loadedModel = gltf.scene;
                
                // Get bounding box and center
                const box = new THREE.Box3().setFromObject(loadedModel);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                const scale = 2 / maxDim;
                
                // Center the model at origin first
                loadedModel.position.x = -center.x;
                loadedModel.position.y = -center.y;
                loadedModel.position.z = -center.z;
                
                // Apply scale
                loadedModel.scale.multiplyScalar(scale);
                
                // Add to group and then to scene
                modelGroup.add(loadedModel);
                scene.add(modelGroup);
                
                // Set initial rotation from configuration
                modelGroup.rotation.x = initialRotation.x;
                modelGroup.rotation.y = initialRotation.y;
                modelGroup.rotation.z = initialRotation.z;
                targetRotation.x = initialRotation.x;
                targetRotation.y = initialRotation.y;
                targetRotation.z = initialRotation.z;
                
                // Store the group
                model = modelGroup;
                
                loading.style.display = 'none';
            });
            
            let animationId = null;
            
            function animate() {
                animationId = requestAnimationFrame(animate);
                
                if (model) {
                    // WASD keyboard movement - unlimited range
                    if (keys['w']) targetZ -= moveSpeed;
                    if (keys['s']) targetZ += moveSpeed;
                    if (keys['a']) camera.position.x -= moveSpeed;
                    if (keys['d']) camera.position.x += moveSpeed;
                    
                    // Button movement (when held down) - unlimited range
                    if (buttonMovement.forward) targetZ -= moveSpeed;
                    if (buttonMovement.backward) targetZ += moveSpeed;
                    if (buttonMovement.left) camera.position.x -= moveSpeed;
                    if (buttonMovement.right) camera.position.x += moveSpeed;
                    
                    // Smooth camera movement
                    camera.position.z += (targetZ - camera.position.z) * 0.1;
                    
                    // Smooth rotation controlled by dragging
                    model.rotation.x += (targetRotation.x - model.rotation.x) * 0.1;
                    model.rotation.y += (targetRotation.y - model.rotation.y) * 0.1;
                    model.rotation.z += (targetRotation.z - model.rotation.z) * 0.1;
                }
                
                camera.lookAt(scene.position);
                renderer.render(scene, camera);
            }
            
            animate();
            
            // Return an object with dispose method to clean up resources
            return {
                dispose: function() {
                    // Cancel animation
                    if (animationId) {
                        cancelAnimationFrame(animationId);
                    }
                    
                    // Dispose of model
                    if (model) {
                        model.traverse((child) => {
                            if (child.geometry) {
                                child.geometry.dispose();
                            }
                            if (child.material) {
                                if (Array.isArray(child.material)) {
                                    child.material.forEach(material => {
                                        if (material.map) material.map.dispose();
                                        material.dispose();
                                    });
                                } else {
                                    if (child.material.map) child.material.map.dispose();
                                    child.material.dispose();
                                }
                            }
                        });
                        scene.remove(model);
                    }
                    
                    // Dispose of renderer
                    if (renderer) {
                        renderer.dispose();
                        if (renderer.domElement && renderer.domElement.parentNode) {
                            renderer.domElement.parentNode.removeChild(renderer.domElement);
                        }
                    }
                    
                    // Clear scene
                    scene.clear();
                    
                    console.log(`Disposed viewer: ${containerId}`);
                }
            };
        }
        
        window.addEventListener('load', () => {
            // ========== MODEL URLS: Change these for your model ==========
            const model1 = {
                glb: 'https://vlyzifpqemfanxllnmuf.supabase.co/storage/v1/object/public/files/Qitian/3d/book_1760561218381.glb',
                usdz: 'https://vlyzifpqemfanxllnmuf.supabase.co/storage/v1/object/public/files/Qitian/other/Book_1762051360290.usdz'
            };
            // =============================================================
            
            // TESTING MODE: Set to true to show AR button on all devices (for testing layout/styling)
            const TESTING_MODE = true; // Change to false when testing on actual iPhone
            
            // Store viewer instances to dispose of them later
            const viewerInstances = new Map();
            
            // Configuration for the model viewer
            const modelConfigs = [
                { containerId: 'model1', arButtonId: 'ar-button', zoomInId: 'zoom-in', zoomOutId: 'zoom-out', 
                  moveForwardId: 'move-forward', moveBackwardId: 'move-backward', moveLeftId: 'move-left', moveRightId: 'move-right',
                  glb: model1.glb, usdz: model1.usdz }
            ];
            
            // Create Intersection Observer to lazy load models
            const observerOptions = {
                root: null,
                rootMargin: '100px', // Start loading 100px before entering viewport
                threshold: 0.1
            };
            
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    const containerId = entry.target.id;
                    
                    if (entry.isIntersecting) {
                        // Model is visible - load it if not already loaded
                        if (!viewerInstances.has(containerId)) {
                            console.log(`Loading model: ${containerId}`);
                            const config = modelConfigs.find(c => c.containerId === containerId);
                            if (config) {
                                const viewer = init3DViewer(
                                    config.containerId, config.arButtonId, config.zoomInId, config.zoomOutId,
                                    config.moveForwardId, config.moveBackwardId, config.moveLeftId, config.moveRightId,
                                    config.glb, config.usdz, TESTING_MODE
                                );
                                viewerInstances.set(containerId, viewer);
                            }
                        }
                    } else {
                        // Model is not visible - dispose of it to free memory
                        if (viewerInstances.has(containerId)) {
                            console.log(`Unloading model: ${containerId}`);
                            const viewer = viewerInstances.get(containerId);
                            if (viewer && viewer.dispose) {
                                viewer.dispose();
                            }
                            viewerInstances.delete(containerId);
                        }
                    }
                });
            }, observerOptions);
            
            // Observe all model containers
            modelConfigs.forEach(config => {
                const container = document.getElementById(config.containerId);
                if (container) {
                    observer.observe(container);
                }
            });
        });
    </script>
</body>
</html>
